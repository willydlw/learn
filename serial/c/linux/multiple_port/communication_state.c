/**
 * Copyright (c) 2017 willydlw
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the MIT license. See `main.c` for details.
 */


/**@file communication_state.c
* 
* @brief Communication State
*
*
* @author willydlw
* @date 30 Jan 2018
* @bugs No known bugs
*
*/


#include <errno.h>
#include <string.h>
#include <termios.h>		// speed_t
#include <sys/time.h>

#include "serial.h"
#include "communication_state.h"


/* ========== Initialize External Global Constants     ========= */

const char* debug_operational_state_string[] =
{
	"WAIT_FOR_CONNECTION" ,
	"ACKNOWLEDGE_CONNECTION",
	"WAIT_FOR_SENSOR_ID",
	"SENSOR_REGISTRATION_COMPLETE",
	"RECEIVE_SENSOR_DATA",
	"NOT_OPERATIONAL"
};


const char* debug_read_write_message_state_string[] = 
		{ "START_MARKER", "DATA_BYTE_ONE",
		  "DATA_BYTE_TWO", "DATA BYTE THREE",
		  "END_MARKER"};



const char* debug_error_condition_string[] = { 
	"SUCCESS", "SELECT_FAILURE", "SELECT_ZERO_COUNT" };



/**
* @brief Messages transmitted to connected device
*/
const char* ackResponse = "<ACK>";
const char* readyResponse = "<RDY>";
const char* resetCommand = "<RST>";
const char* stopCommand = "<STP>";



/**
* @brief Messages received from connected device
*/
const char* helloMessage = "<HLO>";
const char* helloMessageHEX = "3C 48 4C 4F 3E";



/**
* @brief message markers
*/
const uint8_t start_marker = '<';
const uint8_t end_marker = '>';




/** @brief Checks value of selectfds and returns error state.
*          In the case of a select failure error, a LOG_ERROR
*          level message is generated, including the string describing errnum.
*
* @param[in] selectfds      pselect return value, number of file descriptors 
* @param[in] errnum         errno generated by an error condition
*	    
* @return
*   SUCCESS                 when selectfds > 0
*   SELECT_ZERO_COUNT       when selectfds equals zero
*   SELECT_FAILURE 	        when selectfds < 0
*
*/
ErrorCondition check_select_return_value(int selectfds, int errnum)
{
	if(selectfds < 0 && errnum != EINTR){   // EINTR means signal was caught
		
		log_error("select failure, errno: %s", strerror(errnum));
        
        /* Errors:  
            EBADF - invalid file descriptor. Possible fd closed, or in error state
            EINTR - signal was caught
            EINVAL - nfds is negative or timeout value is invalid
            ENOMEM - unable to allocate memory for internal tables.
        */
        return SELECT_FAILURE;
     }
    else if(selectfds == 0){
    	// in the long run, may not need to maintain this stat
        // there may be times when no data has been received
        // nor is there data to write, depends on timing of this loop
        // With a two second timeout, it is unlikely that there will
        // never be sensor data to read when the operational state
        // is RECEIVE_SENSOR_DATA
    	log_debug("select returned zero");
    	return SELECT_ZERO_COUNT;
    }

    return SUCCESS;
}



/** @brief Reads data bytes from the serial file descriptor fd.
*          A maximum of MESSAGE_LENGTH_BYTES are read and stored in buf.
*
*
* @param[in]    fd		    file descriptor
* @param[in]    readfds	    read file descriptor set
*	    
* @param[out] buf           buffer which stores bytes read
*	    								  
* @return bytes read
*      
*/
ssize_t read_message(int fd, fd_set readfds, uint8_t *buf)
{

	ssize_t bytes_read = 0;

	if(FD_ISSET(fd, &readfds)){

        // restricts number of bytes read to a maximum of the length 
        // of a complete message. 
        bytes_read = serial_read(fd, buf, READ_MESSAGE_LENGTH_BYTES ); 
    }
    else{
    	log_debug("FD_ISSET(fd, &readfds) not true for fd %d", fd);
    }

    return bytes_read;
            
}



/** @brief Transmits a message
*              
*
* @param[in] fd		  		  file descriptor
* @param[in] writefds		  write file descriptor set
* @param[in] buf              buffer containing bytes to transmit
* @param[in] numBytes         number of bytes to transmit
*    								  
* @return number of bytes transmitted
*
*/
ssize_t write_message(int fd, fd_set writefds, uint8_t *buf, size_t numBytes)
{
	ssize_t bytesWritten = 0;

    if(FD_ISSET(fd, &writefds)){

    	bytesWritten = serial_write(fd, (const char*)buf, numBytes);
   		   		
    }
    else{
    	log_debug("FD_ISSET(fd, &writefds) not true for fd %d", fd);
    }

    return bytesWritten;   
}




/** @brief Stub function that is called to log the device data
*          which has been extracted from the received message.
*
* @param[in] theData    device data received
*
* @return void
*
* @note When integrating these functions into an application
*       this function should be modified to properly handle
*       received data.
*
*/   
void process_sensor_data_received(uint16_t theData)
{
	log_trace("theData: %u", theData);	
}



/** @brief Converts numbers to equivalent hex string
*
*   Example: 254 is decimal value stored in source array
*            "FE" is character string, hex representation of 254
*
* @param[in] source     array containing numbers to be converted
* @param[in] slength    number of elements in source array
* @param[in] dlength    number of elements in destination array
*
* @param[out] destination   array containing string representation
*
* @note: dlength must be 3*salength + 1
* 
*/
void convert_array_to_hex_string(char* destination, ssize_t dlength, const uint8_t* source, ssize_t slength)
{
	ssize_t i;
	memset(destination, 0, (size_t)dlength);
	for(i = 0; i < slength; ++i){
		sprintf(&destination[i*3], "%02x ", source[i]); 
	}
} 

