

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>		// speed_t
#include <sys/time.h>

#include "serial.h"
#include "communication_state.h"


/* ========== Initialize External Global Constants     ========= */

const char* debug_operational_state_string[] =
{
	"WAIT_FOR_CONNECTION" ,
	"ACKNOWLEDGE_CONNECTION",
	"WAIT_FOR_SENSOR_ID",
	"SENSOR_REGISTRATION_COMPLETE",
	"RECEIVE_SENSOR_DATA",
	"NOT_OPERATIONAL"
};


const char* debug_message_state_string[] = 
		{ "AWAITING_START_MARKER", "AWAITING_SENSOR_ID", "AWAITING_DATA_BYTE_ONE",
		  "AWAITING_DATA_BYTE_TWO", "AWAITING_DATA_BYTE_THREE", 
		  "AWAITING_END_MARKER", "MESSAGE_COMPLETE", "NOT_COMMUNICATING"};



const char* debug_comm_read_state_string[] = 
	{	"NO_READ", "WAIT_FOR_CONNECTION", "READ_ACK", "READ_SENSOR" };



const char* debug_comm_write_state_string[] = 
	{	"NO_WRITE", "SEND_READY_SIGNAL", "SEND_RESET",  "SEND_STOP"};



const char* debug_error_condition_string[] = { 
	"SUCCESS", "SELECT_FAILURE", "SELECT_ZERO_COUNT", 
	"SERIAL_WRITE_ERROR", "FD_ISSET_ERROR"  };


/** Note: The messages and commands are in common with the 
          paired Arduino program. These would be easier to 
          maintain if they were in a common file. 

          Currently, using the Arduino IDE requires that the
          file be in Arduino/libraries. As these are testing
          files, and not yet production, the data is maintained
          here and in sensor_coummunication.h
*/

// request messages
const char* readyCommand = "<RDY>";
const char* resetCommand = "<RST>";
const char* stopCommand = "<STP>";

// response messages
const char* ackResponse = "<ACK>";
const char* nackResponse = "<NCK>";


/** When another program opens the serial
    connection, the Arduino program resets.

    This message is broadcast to confirm
    the connection has been made.
**/
const char* helloMessage = "<HLO>";
const char* helloMessageHEX = "3C 48 4C 4F 3E";


static const uint8_t start_marker = '<';
static const uint8_t end_marker = '>';


// end of data in common with Arduino

static const uint8_t sensor_id[1] = {'1'};




/**
* NAME : ErrorCondition check_select_return_value(int selectfds, int errnum, int *zeroCount)
*
* DESCRIPTION: Checks value of selectfds and returns error state.
*              In the case of a select failure error, an error message is 
*			   written to stderr, including the string describing errnum.
*
* INPUTS: 
*   Parameters:
*       int             selectfds		  pselect return value, number of file descriptors 
*	    int 			errnum            errno generated by an error condition
*	    
*
* OUTPUTS:
*		int*			zeroCount         pointer to counter that totals how many times
*	    								  pselect returns zero
*   Return:
*       type:			ErrorCondition
*
*		returns SUCCESS when selectfds > 0
*		returns SELECT_ZERO_COUNT when selectfds equals zero, adds 1 to zeroCount
*       return SELECT_FAILURE 	when selectfds < 0
*
*      
* NOTES:
*       
*
*/

ErrorCondition check_select_return_value(int selectfds, int errnum, int *zeroCount)
{
	if(selectfds < 0 && errnum != EINTR){   // EINTR means signal was caught
		
		log_error("select failure, errno: %s", strerror(errnum));
        
        /* Errors:  
            EBADF - invalid file descriptor. Possible fd closed, or in error state
            EINTR - signal was caught
            EINVAL - nfds is negative or timeout value is invalid
            ENOMEM - unable to allocate memory for internal tables.
        */
        return SELECT_FAILURE;
     }
    else if(selectfds == 0){
    	*zeroCount = *zeroCount + 1;
    	return SELECT_ZERO_COUNT;
    }

    return SUCCESS;
}

/**
* NAME : ssize_t read_message(int fd, fd_set readfds, uint8_t *buf)
*
* DESCRIPTION: Reads data bytes from the serial file descriptor fd.
*              A maximum of MESSAGE_LENGTH_BYTES are read and stored in buf.
*
*              
* INPUTS: 
*   Parameters:
*       int             fd		  		  file descriptor
*	    fd_set          readfds			  read file descriptor set
*	    
*
* OUTPUTS:
*		uint8_t*		buf 			  buffer which stores bytes read
*	    								  
*   Return:
*       type:			ssize_t
*
*		returns bytes read
*      
* NOTES:
*       
*
*/
ssize_t read_message(int fd, fd_set readfds, uint8_t *buf)
{
	// since this function will be called numerous times, making 
	// bytes_read static will save time popping it on/off stack
	// will use less stack space
	static ssize_t bytes_read = 0;

	if(FD_ISSET(fd, &readfds)){

        // restricting to read maximum of the length of a complete
        // message. 
        bytes_read = serial_read(fd, buf, MESSAGE_LENGTH_BYTES );

        // debug
        char debugBuffer[3*bytes_read + 1];
        convert_array_to_hex_string(debugBuffer, 3*bytes_read+1, buf, bytes_read);

        log_trace("bytes_read: %ld, bytes: %s\n", bytes_read, debugBuffer);

        // end debug
        
    }

    return bytes_read;
            
}


/**
* NAME : ErrorCondition write_message(int fd, fd_set writefds, CommWriteState commWriteState)
*
* DESCRIPTION: Transmits a message, dependent on commWriteState
*              
*
*              
* INPUTS: 
*   Parameters:
*       int             fd		  		  file descriptor
*	    fd_set          writefds		  write file descriptor set
*	    CommWriteState  CommWriteState    communication write state
*
* OUTPUTS:
*	    								  
*   Return:
*       type:			ErrorCondition
*
*		returns SUCCESS				when all message bytes are transmitted
*
*		returns SERIAL_WRITE_ERROR 	when the fd is available, but not
*								   	all bytes are transitted
*
*		returns FD_ISSET_ERROR 		when the file descriptor is not available 
*							   		in the write set 
*      
* NOTES:
*       
*
*/
ErrorCondition write_message(int fd, fd_set writefds, CommWriteState commWriteState)
{        	
    if(FD_ISSET(fd, &writefds)){

    	ssize_t bytes_written;
    	size_t expected_bytes;
   		
   		switch(commWriteState){
   			case SEND_READY_SIGNAL:
   				expected_bytes = strlen(readyCommand);
   				bytes_written = serial_write(fd, readyCommand, expected_bytes);
   				
   			break;

   			case SEND_RESET:
   				expected_bytes = strlen(resetCommand);
   				bytes_written = serial_write(fd, resetCommand, expected_bytes);
   				
   			break;

   			case SEND_STOP:
   				expected_bytes = strlen(resetCommand);
   				bytes_written = serial_write(fd, resetCommand, expected_bytes);
   			break;
   			default:
   				log_warn("commWriteState: %#x", (unsigned int)commWriteState);
   		}

   		return (ssize_t)expected_bytes == bytes_written? SUCCESS:SERIAL_WRITE_ERROR;
    }
    else{
    	log_warn("FD_ISSET(fd, &writefds) not true for fd %d", fd);
    	return FD_ISSET_ERROR;
    }
    
}





/**
* NAME : ssize_t process_received_message_bytes(MessageState *msgState, 
*												const uint8_t *buf, 
*												ssize_t bytes_read, 
*												uint8_t *responseData)
*
* DESCRIPTION: Based on the message state, bytes are copied from buf
*              to the appropriate position in responsedData.
*
*			   The message state is updated with each byte transferred.
*
*			   The fucntion returns When the MESSAGE_COMPLETE state is reached,
*			   or when bytes_read have been transferred. t
*
*              
* INPUTS: 
*   Parameters:
*       MessageState* 	msgState       	  pointer to the message state
*	    const uint8_t*  buf 			  buffer containing serial bytes read
*	    ssize_t			bytes_read		  number of bytes in buf
*
* OUTPUTS:
*
*	    MessageState*   msgState          message state is updated as bytes
*                                         are read from buf and stored in 
*										  responseData
*
*		uint8_t*		responseData      bytes extracted from buf
*	    	
*							  
*   Return:
*       type:			ssize_t
*
*		number of bytes that were not transferred from buf to responseData
*
*      
* NOTES:
*		When the message state is AWAITING_START_MARKER and the start marker
*		is not read, an error message is printed. The state does change
*		until the start marker is read.
*
*		If the default case of the message state machine is reached, an
*		error message is printed, and the message state is set to 
*		AWAITING_START_MARKER. Some data may be lost. The default case
*       should never be reached.
*
*/
ssize_t process_received_message_bytes(MessageState *msgState, const uint8_t *buf, 
											ssize_t bytes_read, uint8_t *responseData)
{
	
	log_trace("start of function, message state: %s\n", debug_message_state_string[*msgState]);

	ssize_t i;
	ssize_t bytes_remaining;
	
	for(i = 0, bytes_remaining = bytes_read; i < bytes_read; ++i){

		log_trace("i: %ld, message state: %25s, buf[i]: %#4x, (char)buf[i]: %c\n", 
							i, debug_message_state_string[*msgState], buf[i], (char)buf[i]);

		--bytes_remaining;

		switch(*msgState){
			case AWAITING_START_MARKER:
				if((char)buf[i] == start_marker){
					memset(responseData, '\0', (MESSAGE_LENGTH_BYTES+1)*sizeof(uint8_t) );
					responseData[0] = buf[i];
					*msgState = AWAITING_DATA_BYTE_ONE;
				}
				else { 
					log_warn("state: AWAITING_START_MARKER, buf[%ld]: %#x\n", i, buf[i]);
				}
				break;

			case AWAITING_DATA_BYTE_ONE:
				responseData[1] = buf[i];
				*msgState = AWAITING_DATA_BYTE_TWO;
				break;

			case AWAITING_DATA_BYTE_TWO:
				responseData[2] = buf[i];
				*msgState = AWAITING_DATA_BYTE_THREE;
				break;

			case AWAITING_DATA_BYTE_THREE:
				responseData[3] = buf[i];
				*msgState = AWAITING_END_MARKER;
				break;

			case AWAITING_END_MARKER:
				responseData[4] = buf[i];
				responseData[5] = '\0';     // null terminate the string
				*msgState = MESSAGE_COMPLETE;
				return bytes_remaining;	// bytes not processed

			default:
				log_error("reached default case, msgState: %#x, "
							"message_state_string: %s", (unsigned int) *msgState, 
						*msgState < NUM_MESSAGE_STATES? 
								debug_message_state_string[*msgState]:"unknown");
				
				// set message state to await start of new message
				// throw away the unkown message bytes
				*msgState = AWAITING_START_MARKER;
		}
	}
	return bytes_remaining;
}



	


bool valid_sensor_id(uint8_t id){
	// @TODO: need a scheme for quickly validating sensor ids
	//        once multiple sensors are handled
	if(id == sensor_id[0])
		return true;
	else 
		return false;
}


void process_sensor_data_received(uint16_t theData)
{
	log_trace("theData: %u", theData);	
	log_trace("TODO: this is only a stub function, need to determine how to handle"
					" real time data updates\n");
}


void convert_array_to_hex_string(char* destination, ssize_t dlength, const uint8_t* source, ssize_t slength)
{
	ssize_t i;
	memset(destination, 0, (size_t)dlength);
	for(i = 0; i < slength; ++i){
		sprintf(&destination[i*3], "%02x ", source[i]); 
	}
}

void process_read_state_error_message(CommReadState commReadState, 
	const uint8_t *responseData, ssize_t rlength)
{
	//char hexmsg[3*MESSAGE_LENGTH_BYTES + 1];
	char hexmsg[3*rlength+1];

    convert_array_to_hex_string(hexmsg, 
        3*rlength + 1, 
            responseData, rlength);

    log_warn("commReadState: %s\n"
             "\t\thexadecimal expected: %s, received: %s\n"
             "\t\tcharacters  expected: %s, received: %s",
            debug_comm_read_state_string[commReadState],
            helloMessageHEX, hexmsg,
            helloMessage, (const char*)responseData);
}
